import { useState, useEffect, useCallback } from 'react';
import { useGoalSettingData } from './useGoalSettingData';
import { ActionItem, Milestone, GoalSettingData } from '../types/goals';

export interface Event {
  id: string;
  title: string;
  start: Date;
  end: Date;
  category: 'business' | 'body' | 'balance' | 'personal';
  frequency?: 'daily' | 'weekly' | '3x-week';
  completed?: boolean;
  relatedGoal?: string;
  isAutoGenerated?: boolean;
}

export interface ActionPoolItem {
  id: string;
  title: string;
  duration: number;
  category: 'business' | 'body' | 'balance' | 'personal';
  frequency: 'daily' | 'weekly' | '3x-week';
  completed?: boolean;
  relatedGoal?: string;
  priority?: 'high' | 'medium' | 'low';
}

export interface CalendarData {
  events: Event[];
  actionPool: ActionPoolItem[];
  lastUpdated: string;
  autoPopulateSettings: {
    dailyActionsEnabled: boolean;
    defaultDailyStartTime: string;
  };
}

const STORAGE_KEY = 'coach-pack-calendar';

const defaultCalendarData: CalendarData = {
  events: [],
  actionPool: [],
  lastUpdated: new Date().toISOString(),
  autoPopulateSettings: {
    dailyActionsEnabled: true,
    defaultDailyStartTime: "09:00"
  }
};

export const useCalendarData = () => {
  const [data, setData] = useState<CalendarData>(defaultCalendarData);
  const [isLoaded, setIsLoaded] = useState(false);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);
  
  // Get goals data for integration
  const { data: goalsData, isLoaded: goalsLoaded } = useGoalSettingData();

  // Load data on mount
  useEffect(() => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsedData = JSON.parse(stored);
        
        if (parsedData.events) {
          parsedData.events = parsedData.events.map((event: any) => ({
            ...event,
            start: new Date(event.start),
            end: new Date(event.end)
          }));
        }
        
        if (!parsedData.autoPopulateSettings) {
          parsedData.autoPopulateSettings = defaultCalendarData.autoPopulateSettings;
        }
        
        setData(parsedData);
        setLastSaved(new Date(parsedData.lastUpdated));
      } else {
        setData(defaultCalendarData);
      }
    } catch (error) {
      console.error('Failed to load calendar data:', error);
      setData(defaultCalendarData);
    }
    setIsLoaded(true);
  }, []);

  // Load goals into action pool
  const loadGoalsIntoActionPool = useCallback(() => {
    if (!goalsData || !goalsLoaded) return;

    console.log("Loading goals into action pool");
    
    const newActionPool: ActionPoolItem[] = [];
    
    // Keep manually added actions (non-goal-generated)
    data.actionPool.forEach(action => {
      if (!action.isAutoGenerated) {
        newActionPool.push(action);
      }
    });

    // Add actions from goals
    if (goalsData.categoryGoals) {
      Object.entries(goalsData.categoryGoals).forEach(([category, categoryData]: [string, any]) => {
        if (categoryData.actions && Array.isArray(categoryData.actions)) {
          categoryData.actions.forEach((action: ActionItem, index: number) => {
            const calendarCategory = category === 'business' ? 'business' : 
                                   category === 'body' ? 'body' : 'balance';
            
            const actionTitle = action.text || `${category} action`;
            const actionDuration = 60; // Default 60 minutes
            
            newActionPool.push({
              id: `${category}-goal-action-${index}`,
              title: actionTitle,
              duration: actionDuration,
              category: calendarCategory as 'business' | 'body' | 'balance' | 'personal',
              frequency: action.frequency || 'weekly',
              completed: false,
              relatedGoal: category,
              priority: 'medium',
              isAutoGenerated: true
            });
          });
        }
      });
    }

    setData(prev => ({
      ...prev,
      actionPool: newActionPool,
      lastUpdated: new Date().toISOString()
    }));

  }, [goalsData, goalsLoaded, data.actionPool]);

  // Auto-sync when goals data changes
  useEffect(() => {
    if (isLoaded && goalsLoaded) {
      loadGoalsIntoActionPool();
    }
  }, [isLoaded, goalsLoaded, loadGoalsIntoActionPool]);

  // Save data to localStorage
  const saveData = useCallback(() => {
    try {
      const dataToSave = {
        ...data,
        lastUpdated: new Date().toISOString()
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
      setLastSaved(new Date());
      console.log('Calendar data saved successfully');
    } catch (error) {
      console.error('Failed to save calendar data:', error);
    }
  }, [data]);

  // Event management functions
  const addEvent = useCallback((event: Omit<Event, 'id'>) => {
    const newEvent: Event = {
      ...event,
      id: Date.now().toString()
    };
    setData(prev => ({
      ...prev,
      events: [...prev.events, newEvent]
    }));
  }, []);

  const updateEvent = useCallback((eventId: string, updates: Partial<Event>) => {
    setData(prev => ({
      ...prev,
      events: prev.events.map(event => 
        event.id === eventId ? { ...event, ...updates } : event
      )
    }));
  }, []);

  const removeEvent = useCallback((eventId: string) => {
    setData(prev => ({
      ...prev,
      events: prev.events.filter(event => event.id !== eventId)
    }));
  }, []);

  // Action pool management
  const addActionToPool = useCallback((action: Omit<ActionPoolItem, 'id'>) => {
    const newAction: ActionPoolItem = {
      ...action,
      id: Date.now().toString()
    };
    setData(prev => ({
      ...prev,
      actionPool: [...prev.actionPool, newAction]
    }));
  }, []);

  const updateActionInPool = useCallback((actionId: string, updates: Partial<ActionPoolItem>) => {
    setData(prev => ({
      ...prev,
      actionPool: prev.actionPool.map(action => 
        action.id === actionId ? { ...action, ...updates } : action
      )
    }));
  }, []);

  const removeActionFromPool = useCallback((actionId: string) => {
    setData(prev => ({
      ...prev,
      actionPool: prev.actionPool.filter(action => action.id !== actionId)
    }));
  }, []);

  const scheduleActionFromPool = useCallback((actionId: string, date: Date, time: string) => {
    const action = data.actionPool.find(a => a.id === actionId);
    if (!action) return;

    const [hours, minutes] = time.split(':').map(Number);
    const startTime = new Date(date);
    startTime.setHours(hours, minutes, 0, 0);
    
    const endTime = new Date(startTime);
    endTime.setMinutes(startTime.getMinutes() + action.duration);

    const newEvent: Event = {
      id: Date.now().toString(),
      title: action.title,
      start: startTime,
      end: endTime,
      category: action.category,
      relatedGoal: action.relatedGoal,
      isAutoGenerated: false
    };

    addEvent(newEvent);
  }, [data.actionPool, addEvent]);

  const getEventsForDay = useCallback((date: Date) => {
    const dayStart = new Date(date);
    dayStart.setHours(0, 0, 0, 0);
    const dayEnd = new Date(date);
    dayEnd.setHours(23, 59, 59, 999);

    return data.events.filter(event => 
      event.start >= dayStart && event.start <= dayEnd
    );
  }, [data.events]);

  const refreshActionPool = useCallback(() => {
    loadGoalsIntoActionPool();
  }, [loadGoalsIntoActionPool]);

  return {
    data,
    isLoaded,
    lastSaved,
    addEvent,
    updateEvent,
    removeEvent,
    addActionToPool,
    updateActionInPool,
    removeActionFromPool,
    scheduleActionFromPool,
    getEventsForDay,
    refreshActionPool,
    saveData
  };
};