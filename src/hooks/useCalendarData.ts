```typescript
import { useState, useEffect, useCallback } from 'react';
// Import the storage key directly
import { STORAGE_KEY as GOALS_STORAGE_KEY, useGoalSettingData } from './useGoalSettingData';
import { ActionItem, Milestone, GoalSettingData } from '../types/goals';

export interface Event {
  id: string;
  title: string;
  start: Date;
  end: Date;
  category: 'business' | 'body' | 'balance' | 'personal';
  frequency?: 'daily' | 'weekly' | '3x-week';
  completed?: boolean;
  relatedGoal?: string;
  isAutoGenerated?: boolean; // Track if this was auto-generated from daily actions
}

export interface ActionPoolItem {
  id: string;
  title: string;
  duration: number; // in minutes
  category: 'business' | 'body' | 'balance' | 'personal';
  frequency: 'daily' | 'weekly' | '3x-week';
  completed?: boolean;
  relatedGoal?: string;
  priority?: 'high' | 'medium' | 'low';
}

export interface CalendarData {
  events: Event[];
  actionPool: ActionPoolItem[];
  lastUpdated: string;
  autoPopulateSettings: {
    dailyActionsEnabled: boolean;
    defaultDailyStartTime: string; // Format: "HH:MM"
  };
}

const STORAGE_KEY = 'coach-pack-calendar';

const defaultCalendarData: CalendarData = {
  events: [],
  actionPool: [],
  lastUpdated: new Date().toISOString(),
  autoPopulateSettings: {
    dailyActionsEnabled: true,
    defaultDailyStartTime: "09:00"
  }
};

export const useCalendarData = () => {
  const [data, setData] = useState<CalendarData>(defaultCalendarData);
  const [isLoaded, setIsLoaded] = useState(false);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);

  // Import goals data
  const { data: goalsData, isLoaded: goalsLoaded } = useGoalSettingData();

  // Load data on mount
  useEffect(() => {
    try {
      // First try to load calendar data
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsedData = JSON.parse(stored);
        
        // Convert string dates to Date objects
        if (parsedData.events) {
          parsedData.events = parsedData.events.map((event: any) => ({
            ...event,
            start: new Date(event.start),
            end: new Date(event.end)
          }));
        }
        
        // Ensure autoPopulateSettings exists (for backward compatibility)
        if (!parsedData.autoPopulateSettings) {
          parsedData.autoPopulateSettings = defaultCalendarData.autoPopulateSettings;
        }
        
        setData(parsedData);
        setLastSaved(new Date(parsedData.lastUpdated));
      } else {
        // If no calendar data, initialize with empty data
        setData(defaultCalendarData);
      }
      
    } catch (error) {
      console.error('Failed to load calendar data:', error);
      setData(defaultCalendarData);
    }
    setIsLoaded(true);
  }, []);

  // Load goals data into action pool whenever goalsData changes
  const loadGoalsIntoActionPool = useCallback(() => {
    if (!goalsLoaded) {
      console.log("Goals data not yet loaded, skipping action pool refresh.");
      return;
    }

    try {
      console.log("Refreshing action pool from goals data.");
      
      const newActionPool: ActionPoolItem[] = [];
      
      if (goalsData && goalsData.categoryGoals) {
        Object.entries(goalsData.categoryGoals).forEach(([category, categoryData]: [string, any]) => {
          // Map categories to calendar categories
          const calendarCategory = category === 'health' ? 'body' : 
                                 category === 'relationships' ? 'balance' :
                                 category === 'fun' ? 'personal' : 
                                 category; // business stays as business
          
          if (categoryData && typeof categoryData === 'object' && categoryData.actions && Array.isArray(categoryData.actions)) {
            categoryData.actions.forEach((action: any, index: number) => {
              let actionTitle = '';
              let actionFrequency: 'daily' | 'weekly' | '3x-week' = '3x-week';
              let actionDuration = 60; // Default duration
              
              if (typeof action === 'string') {
                actionTitle = action;
              } else if (typeof action === 'object' && action !== null) {
                actionTitle = action.text || ''; // Use 'text' property for action title
                if (action.frequency) {
                  actionFrequency = action.frequency as 'daily' | 'weekly' | '3x-week';
                }
                if (action.duration && typeof action.duration === 'number') {
                  actionDuration = action.duration;
                }
              }
              
              if (actionTitle) {
                newActionPool.push({
                  id: \`${category}-goal-action-${index}`, // Unique ID for goal-generated actions
                  title: actionTitle,
                  duration: actionDuration,
                  category: calendarCategory as 'business' | 'body' | 'balance' | 'personal',
                  frequency: actionFrequency,
                  relatedGoal: categoryData.goal || categoryData.title || 'Goal',
                  priority: action.priority || 'medium'
                });
              }
            });
          }
        });
      }
      
      setData(prev => {
        // Filter out old goal-generated actions and keep only manually added ones
        const manualActions = prev.actionPool.filter(action => 
          !action.id.includes('-goal-action-') // Keep actions not generated from goals
        );
        
        return {
          ...prev,
          actionPool: [...manualActions, ...newActionPool] // Combine manual with fresh goal actions
        };
      });
      
      console.log("Action pool refreshed. Total actions:", newActionPool.length);
    } catch (error) {
      console.error('Failed to load goals into action pool:', error);
    }
  }, [goalsData, goalsLoaded]);

  // Effect to trigger action pool refresh when goals data changes
  useEffect(() => {
    if (isLoaded && goalsLoaded) {
      loadGoalsIntoActionPool();
    }
  }, [isLoaded, goalsLoaded, loadGoalsIntoActionPool]);


  // Auto-save function
  const saveData = useCallback(() => {
    if (!isLoaded) return;

    try {
      const dataToSave: CalendarData = {
        ...data,
        lastUpdated: new Date().toISOString()
      };
      
      localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
      setLastSaved(new Date());
    } catch (error) {
      console.error('Failed to save calendar data:', error);
    }
  }, [data, isLoaded]);

  // Auto-save whenever data changes
  useEffect(() => {
    if (isLoaded) {
      const timeoutId = setTimeout(saveData, 1000); // Debounce saves
      return () => clearTimeout(timeoutId);
    }
  }, [data, saveData, isLoaded]);

  // Event management functions
  const addEvent = useCallback((event: Omit<Event, 'id'>) => {
    const newEvent: Event = {
      ...event,
      id: \`event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    };
    
    setData(prev => ({
      ...prev,
      events: [...prev.events, newEvent]
    }));
    
    return newEvent.id;
  }, []);

  const updateEvent = useCallback((eventId: string, updates: Partial<Event>) => {
    setData(prev => ({
      ...prev,
      events: prev.events.map(event => 
        event.id === eventId ? { ...event, ...updates } : event
      )
    }));
  }, []);

  const removeEvent = useCallback((eventId: string) => {
    setData(prev => ({
      ...prev,
      events: prev.events.filter(event => event.id !== eventId)
    }));
  }, []);

  // Bulk remove auto-generated events (useful for refreshing daily actions)
  const removeAutoGeneratedEvents = useCallback((frequency?: 'daily' | 'weekly') => {
    setData(prev => ({
      ...prev,
      events: prev.events.filter(event => 
        !(event.isAutoGenerated && (!frequency || event.frequency === frequency))
      )
    }));
  }, []);

  // Action pool management
  const addActionToPool = useCallback((action: Omit<ActionPoolItem, 'id'>) => {
    const newAction: ActionPoolItem = {
      ...action,
      id: \`action-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    };
    
    setData(prev => ({
      ...prev,
      actionPool: [...prev.actionPool, newAction]
    }));
    
    return newAction.id;
  }, []);

  const updateActionInPool = useCallback((actionId: string, updates: Partial<ActionPoolItem>) => {
    setData(prev => ({
      ...prev,
      actionPool: prev.actionPool.map(action => 
        action.id === actionId ? { ...action, ...updates } : action
      )
    }));
  }, []);

  const removeActionFromPool = useCallback((actionId: string) => {
    setData(prev => ({
      ...prev,
      actionPool: prev.actionPool.filter(action => action.id !== actionId)
    }));
  }, []);

  // Convert action to event with enhanced scheduling logic
  const scheduleActionFromPool = useCallback((actionId: string, start: Date, options?: {
    removeFromPool?: boolean;
    isAutoGenerated?: boolean;
  }) => {
    const action = data.actionPool.find(a => a.id === actionId);
    if (!action) return null;
    
    const end = new Date(start);
    end.setMinutes(end.getMinutes() + action.duration);
    
    const newEvent: Event = {
      id: \`scheduled-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      title: action.title,
      start,
      end,
      category: action.category,
      frequency: action.frequency,
      relatedGoal: action.relatedGoal,
      isAutoGenerated: options?.isAutoGenerated || false
    };
    
    setData(prev => ({
      ...prev,
      events: [...prev.events, newEvent],
      actionPool: options?.removeFromPool 
        ? prev.actionPool.filter(a => a.id !== actionId)
        : prev.actionPool
    }));
    
    return newEvent.id;
  }, [data.actionPool]);

  // Auto-populate daily actions for a specific date range
  const autoPopulateDailyActions = useCallback((startDate: Date, endDate: Date) => {
    if (!data.autoPopulateSettings.dailyActionsEnabled) return;
    
    const dailyActions = data.actionPool.filter(action => action.frequency === 'daily');
    if (dailyActions.length === 0) return;
    
    // Remove existing auto-generated daily events in the date range
    setData(prev => ({
      ...prev,
      events: prev.events.filter(event => {
        if (!event.isAutoGenerated || event.frequency !== 'daily') return true;
        const eventDate = new Date(event.start);
        return eventDate < startDate || eventDate > endDate;
      })
    }));
    
    // Generate events for each day in the range
    const currentDate = new Date(startDate);
    const [defaultHour, defaultMinute] = data.autoPopulateSettings.defaultDailyStartTime.split(':').map(Number);
    
    while (currentDate <= endDate) {
      dailyActions.forEach((action, index) => {
        const eventStart = new Date(currentDate);
        // Stagger daily actions by 15 minutes to avoid conflicts
        eventStart.setHours(defaultHour, defaultMinute + (index * 15), 0, 0);
        
        const eventEnd = new Date(eventStart);
        eventEnd.setMinutes(eventEnd.getMinutes() + action.duration);
        
        const newEvent: Event = {
          id: \`daily-auto-${action.id}-${currentDate.toISOString().split('T')[0]}`,
          title: action.title,
          start: eventStart,
          end: eventEnd,
          category: action.category,
          frequency: 'daily',
          relatedGoal: action.relatedGoal,
          isAutoGenerated: true
        };
        
        setData(prev => ({
          ...prev,
          events: [...prev.events, newEvent]
        }));
      });
      
      // Move to next day
      currentDate.setDate(currentDate.getDate() + 1);
    }
  }, [data.actionPool, data.autoPopulateSettings]);

  // Utility functions
  const getEventsForDay = useCallback((date: Date): Event[] => {
    return data.events.filter(event => {
      const eventDate = new Date(event.start);
      return eventDate.getDate() === date.getDate() &&
             eventDate.getMonth() === date.getMonth() &&
             eventDate.getFullYear() === date.getFullYear();
    });
  }, [data.events]);

  const getEventsForWeek = useCallback((startDate: Date): Event[] => {
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 7);
    
    return data.events.filter(event => {
      const eventDate = new Date(event.start);
      return eventDate >= startDate && eventDate < endDate;
    });
  }, [data.events]);

  const getActionsByFrequency = useCallback((frequency: 'daily' | 'weekly' | '3x-week') => {
    return data.actionPool.filter(action => action.frequency === frequency);
  }, [data.actionPool]);

  // Check for scheduling conflicts
  const hasSchedulingConflict = useCallback((start: Date, end: Date, excludeEventId?: string): boolean => {
    return data.events.some(event => {
      if (excludeEventId && event.id === excludeEventId) return false;
      
      const eventStart = new Date(event.start);
      const eventEnd = new Date(event.end);
      
      return (start < eventEnd && end > eventStart);
    });
  }, [data.events]);

  // Find next available time slot
  const findNextAvailableSlot = useCallback((preferredStart: Date, duration: number): Date | null => {
    const slotEnd = new Date(preferredStart.getTime() + duration * 60000);
    
    if (!hasSchedulingConflict(preferredStart, slotEnd)) {
      return preferredStart;
    }
    
    // Try finding next available slot within the same day
    const dayStart = new Date(preferredStart);
    dayStart.setHours(6, 0, 0, 0); // Start searching from 6 AM
    
    const dayEnd = new Date(preferredStart);
    dayEnd.setHours(22, 0, 0, 0); // Stop searching at 10 PM
    
    const currentTime = new Date(Math.max(dayStart.getTime(), preferredStart.getTime()));
    
    while (currentTime < dayEnd) {
      const testEnd = new Date(currentTime.getTime() + duration * 60000);
      
      if (!hasSchedulingConflict(currentTime, testEnd)) {
        return new Date(currentTime);
      }
      
      // Move forward by 15 minutes
      currentTime.setMinutes(currentTime.getMinutes() + 15);
    }
    
    return null; // No available slot found
  }, [hasSchedulingConflict]);

  // Update auto-populate settings
  const updateAutoPopulateSettings = useCallback((settings: Partial<CalendarData['autoPopulateSettings']>) => {
    setData(prev => ({
      ...prev,
      autoPopulateSettings: {
        ...prev.autoPopulateSettings,
        ...settings
      }
    }));
  }, []);

  // Refresh action pool from goals
  const refreshActionPool = useCallback(() => {
    loadGoalsIntoActionPool();
  }, [loadGoalsIntoActionPool]);

  return {
    data,
    isLoaded,
    lastSaved,
    addEvent,
    updateEvent,
    removeEvent,
    removeAutoGeneratedEvents,
    addActionToPool,
    updateActionInPool,
    removeActionFromPool,
    scheduleActionFromPool,
    autoPopulateDailyActions,
    getEventsForDay,
    getEventsForWeek,
    getActionsByFrequency,
    hasSchedulingConflict,
    findNextAvailableSlot,
    updateAutoPopulateSettings,
    refreshActionPool,
    saveData
  };
};
```